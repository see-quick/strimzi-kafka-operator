# User Operator Model-Based Testing (MBT)

## Overview

This project uses Model-Based Testing (MBT) to verify the behavior of the Strimzi User Operator by replaying traces generated from a formal [Quint](https://quint-lang.org/) model.

The [Quint](https://quint-lang.org/) model (UserOperatorModel.qnt) defines an abstract state machine of KafkaUser resources, Secrets, and the associated lifecycle operations (createUser, updateUser, deleteUser, and reconciliation).

The real Java implementation (UserControllerModelMbtIT) replays the generated traces (e.g., test_case<number-id>.json) against the live User Operator code, verifying that real executions match the model.

This ensures that the User Operator behaves consistently across different inputs, updates, secret management, quota settings, and ACLs.

## Structure

| Component                          | Description                                                                           |
|------------------------------------|---------------------------------------------------------------------------------------|
| `UserOperatorModel.qnt`            | Quint specification defining the abstract model of KafkaUser management.              |
| `UserControllerModelMbtIT.java`    | Java test that replays traces generated by the Quint model.                           |
| `KafkaUserModelActions.java`       | Abstraction for creating, updating, and deleting real KafkaUser resources during MBT. |
| `ResourceUtils.java`               | Helper utilities for working with KafkaUsers, Secrets, and configurations.            |
| `/resources/specification/traces/` | JSON traces generated from the Quint model (e.g., `test_case0.json`).                 |

## User Operator Quint Model

### üìÑ UserOperatorModel.qnt
-	Defines types like KafkaUserSpec, KafkaUserStatus, SimpleAclRule, etc.
- Models:
  - Authentication: SCRAM, TLS, None.
  -	Authorization: Simple ACLs. 
  - Quotas: Rate limits for users. 
  - Secrets: Creation and deletion based on authentication type. 
  - Models the GlobalState with:
  - Current KafkaUsers
    -	Secrets
    -	Event Queue
    -	Number of Processed Events
  - Defines actions:
    - createUser
    - updateUser
    -	deleteUser
    - processNextEvent 
  - Invariants:
    -	Secret and user consistency
    -	Quotas validity
    -	ACLs correctness
  - Temporal property:
    -	Eventually Stable Reconciliation: After sufficient processing, the system becomes stable (no pending events, users are either ‚ÄúReady‚Äù or ‚ÄúDeleted‚Äù).

### Model-Based Test Runner

#### üõ† UserControllerModelMbtIT.java
-	Reads JSON traces (like test_case0.json) produced by the Quint model.
-	For each step in the trace:
    -	Executes the corresponding action (create, update, delete).
    -	Verifies invariants after each step (user consistency, secret presence, ACLs, quotas).
    -	Uses a real Kafka cluster (via Testcontainers).
    -	Starts and stops a real instance of the Strimzi User Operator.
    -	Ensures that reality matches the model‚Äôs expectations.

### Generated Traces

üìÇ /resources/specification/traces/
-	JSON files representing execution traces.
-	Each trace is produced by running `quint run UserOperatorModel.qnt --mbt --max-steps 200 --n-traces 5 --out-itf <path_where_to_generate>`.
-	These traces are automatically replayed in UserControllerModelMbtIT.

#### Example Test Flow

1.	Quint model generates a trace (this could be static as we would like to run same traces each build (and not have different ones, which would cause potential flakiness/failures).
2.	Java test runner loads the trace.
3.	KafkaUserModelActions apply real Kubernetes operations.
4.	InvariantChecker verifies model properties against Kubernetes state.
5.	Full round-trip test: Formal model ‚ûî Real System ‚ûî Validation.