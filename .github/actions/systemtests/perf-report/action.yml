name: "Performance Report Generator"
description: "Parses performance test results and generates a markdown summary for GitHub Actions"

inputs:
  performance-dir:
    description: "Path to the performance results directory"
    required: false
    default: "systemtest/target/performance"

outputs:
  summary:
    description: "Markdown summary of performance results"
    value: ${{ steps.generate_report.outputs.summary }}
  has-results:
    description: "Whether performance results were found"
    value: ${{ steps.generate_report.outputs.has_results }}
  timestamp:
    description: "Timestamp of the performance test run"
    value: ${{ steps.generate_report.outputs.timestamp }}

runs:
  using: "composite"
  steps:
    - name: Generate Performance Report
      id: generate_report
      uses: actions/github-script@v7
      env:
        PERF_DIR: ${{ inputs.performance-dir }}
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const perfDir = process.env.PERF_DIR || 'systemtest/target/performance';

          /**
           * Find the latest timestamped results directory
           */
          function findLatestResultsDir(baseDir) {
            if (!fs.existsSync(baseDir)) {
              core.warning(`Performance directory not found: ${baseDir}`);
              return null;
            }

            const entries = fs.readdirSync(baseDir, { withFileTypes: true });
            const timestampDirs = entries
              .filter(entry => entry.isDirectory())
              .map(entry => entry.name)
              .sort()
              .reverse();

            if (timestampDirs.length === 0) {
              core.warning(`No timestamp directories found in ${baseDir}`);
              return null;
            }

            return path.join(baseDir, timestampDirs[0]);
          }

          /**
           * Parse a results-table.txt file
           */
          function parseResultsTable(tableFile) {
            if (!fs.existsSync(tableFile)) {
              return null;
            }

            const content = fs.readFileSync(tableFile, 'utf8');
            const lines = content.trim().split('\n');

            if (lines.length === 0) {
              return null;
            }

            // Extract use case name from first line
            const useCase = lines[0].replace('Use Case: ', '').trim();

            // Find data lines (lines starting with |, excluding separator lines with +)
            const dataLines = lines.filter(line => line.startsWith('|') && !line.startsWith('+'));

            if (dataLines.length < 2) {
              return { useCase, experiments: [], rawTable: content };
            }

            // Parse header
            const header = dataLines[0].split('|')
              .slice(1, -1)
              .map(col => col.trim());

            // Parse experiment rows
            const experiments = [];
            for (let i = 1; i < dataLines.length; i++) {
              const values = dataLines[i].split('|')
                .slice(1, -1)
                .map(col => col.trim());

              if (values.length === header.length) {
                const experiment = {};
                header.forEach((h, idx) => {
                  experiment[h] = values[idx];
                });
                experiments.push(experiment);
              }
            }

            return {
              useCase,
              header,
              experiments,
              rawTable: content
            };
          }

          /**
           * Parse results for a specific operator
           */
          function parseOperatorResults(operatorDir) {
            if (!fs.existsSync(operatorDir)) {
              return null;
            }

            const resultsTablePath = path.join(operatorDir, 'results-table.txt');
            const operatorName = path.basename(operatorDir);

            return {
              operator: operatorName,
              resultsTable: parseResultsTable(resultsTablePath)
            };
          }

          /**
           * Generate markdown summary
           */
          function generateMarkdownSummary(results) {
            const lines = [
              '# Performance Test Results',
              '',
              `**Test Run:** \`${results.timestamp}\``,
              ''
            ];

            for (const [operatorName, operatorData] of Object.entries(results.operators)) {
              if (!operatorData || !operatorData.resultsTable) {
                continue;
              }

              const title = operatorName.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
              lines.push(`## ${title}`);
              lines.push('');

              const tableData = operatorData.resultsTable;

              if (!tableData.experiments || tableData.experiments.length === 0) {
                lines.push('_No results available_');
                lines.push('');
                continue;
              }

              lines.push(`**Use Case:** ${tableData.useCase}`);
              lines.push('');

              // Add the raw table
              lines.push('```');
              lines.push(tableData.rawTable);
              lines.push('```');
              lines.push('');

              // Add key metrics summary
              const outputCol = tableData.header.find(h => h.includes('OUT:'));

              if (outputCol && tableData.experiments.length > 0) {
                lines.push('### Key Metrics');
                lines.push('');

                const values = tableData.experiments
                  .map(exp => parseInt(exp[outputCol].replace(/,/g, ''), 10))
                  .filter(v => !isNaN(v));

                if (values.length > 0) {
                  const min = Math.min(...values);
                  const max = Math.max(...values);
                  const avg = Math.floor(values.reduce((a, b) => a + b, 0) / values.length);

                  lines.push(`- **Min ${outputCol}:** ${min.toLocaleString()} ms`);
                  lines.push(`- **Max ${outputCol}:** ${max.toLocaleString()} ms`);
                  lines.push(`- **Avg ${outputCol}:** ${avg.toLocaleString()} ms`);
                  lines.push('');
                }
              }
            }

            lines.push('---');
            lines.push('_Performance results generated automatically_');

            return lines.join('\n');
          }

          // Main execution
          try {
            const latestDir = findLatestResultsDir(perfDir);

            if (!latestDir) {
              core.setOutput('has_results', 'false');
              core.setOutput('summary', '_No performance results found_');
              core.setOutput('timestamp', '');
              return;
            }

            const timestamp = path.basename(latestDir);
            core.info(`Found performance results: ${timestamp}`);

            const results = {
              timestamp,
              operators: {}
            };

            // Parse topic-operator results
            const topicOpDir = path.join(latestDir, 'topic-operator');
            const topicOpResults = parseOperatorResults(topicOpDir);
            if (topicOpResults) {
              results.operators['topic-operator'] = topicOpResults;
            }

            // Parse user-operator results
            const userOpDir = path.join(latestDir, 'user-operator');
            const userOpResults = parseOperatorResults(userOpDir);
            if (userOpResults) {
              results.operators['user-operator'] = userOpResults;
            }

            const summary = generateMarkdownSummary(results);

            core.setOutput('has_results', 'true');
            core.setOutput('summary', summary);
            core.setOutput('timestamp', timestamp);

            core.info('Performance report generated successfully');

          } catch (error) {
            core.error(`Error generating performance report: ${error.message}`);
            core.setOutput('has_results', 'false');
            core.setOutput('summary', `_Error generating performance report: ${error.message}_`);
            core.setOutput('timestamp', '');
          }